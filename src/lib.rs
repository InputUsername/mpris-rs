#![warn(missing_docs)]
#![deny(missing_debug_implementations, missing_copy_implementations,
        trivial_casts, trivial_numeric_casts,
        unsafe_code,
        unstable_features,
        unused_import_braces, unused_qualifications)]

//!
//! # mpris
//!
//! `mpris` is an idiomatic library for dealing with MPRIS2-compatible media players over D-Bus.
//!
//! This would mostly apply to the Linux-ecosystem which is a heavy user of D-Bus.
//!
//! ## Getting started
//!
//! Some hints on how to use this library:
//!
//! 1. Look at the examples under `examples/`.
//! 2. Look at the `PlayerFinder` struct.
//!

#[macro_use] extern crate failure_derive;
extern crate failure;

#[macro_use]
extern crate error_chain;
extern crate dbus;

/// Module containing all the error types.
///
/// This is generated by [`error-chain`][error-chain], which makes it possible to integrate to other crates' uses
/// of `error-chain`.
///
/// [error-chain]: https://crates.io/crates/error-chain
#[allow(missing_docs)]
pub mod errors {
    error_chain!{
        foreign_links {
            DBusError(::dbus::Error);
        }

        errors {
            /// No MPRIS2-compatible player could be found.
            NoPlayerFound {
                description("No player found")
                display("Could not find a compatible MPRIS2 player running right now.")
            }

            /// Something went wrong with a D-Bus call or parsing the results from it.
            DBusCallError(message: String) {
                description("D-Bus call failed")
                display("D-Bus call failed: {}", message)
            }
        }
    }
}

mod generated;
mod extensions;

mod pooled_connection;
mod find;
mod metadata;
mod player;
mod progress;

mod prelude {
    pub use errors::*;
}

pub use find::PlayerFinder;
pub use metadata::{Metadata, MetadataError};
pub use player::Player;
pub use progress::{Progress, ProgressTracker};

#[derive(Debug, PartialEq, Eq, Copy, Clone)]
#[allow(missing_docs)]
pub enum PlaybackStatus {
    Playing,
    Paused,
    Stopped,
}

/// PlaybackStatus had an invalid string value.
#[derive(Fail, Debug)]
#[fail(display = "PlaybackStatus must be one of Playing, Paused, Stopped, but was {}", _0)]
pub struct InvalidPlaybackStatus(String);

impl ::std::str::FromStr for PlaybackStatus {
    type Err = InvalidPlaybackStatus;

    fn from_str(string: &str) -> Result<Self, Self::Err> {
        use PlaybackStatus::*;

        match string {
            "Playing" => Ok(Playing),
            "Paused" => Ok(Paused),
            "Stopped" => Ok(Stopped),
            other => Err(
                InvalidPlaybackStatus(other.to_string()),
            ),
        }
    }
}

/// An underlying D-Bus error, represented as a `Fail`ure.
///
/// The `dbus::Error` type is not `Sync` and cannot be represented in a `Fail`, so the
/// error's message is stored instead.
#[derive(Fail, Debug)]
#[fail(display = "D-Bus call failed: {}", message)]
pub struct DBusError {
    /// The reported error message from the underlying D-Bus error.
    message: String
}

impl From<dbus::Error> for DBusError {
    fn from(error: dbus::Error) -> Self {
        DBusError {
            message: error.message().unwrap_or("No error message present").to_string(),
        }
    }
}
